"use strict";
var Promise = require("bluebird");
var fiberBootstrap = require("./fiber-bootstrap");
var assert = require("assert");
var helpers_1 = require("./helpers");
function exportedPromise(moduleName, postAction) {
    return function (target, propertyKey, descriptor) {
        $injector.publicApi.__modules__[moduleName] = $injector.publicApi.__modules__[moduleName] || {};
        $injector.publicApi.__modules__[moduleName][propertyKey] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var originalModule = $injector.resolve(moduleName);
            var originalMethod = originalModule[propertyKey];
            var result;
            try {
                result = originalMethod.apply(originalModule, args);
            }
            catch (err) {
                var promise = new Promise(function (onFulfilled, onRejected) {
                    onRejected(err);
                });
                return promise;
            }
            var types = _(result)
                .groupBy(function (f) { return typeof f; })
                .keys()
                .value(), postActionMethod = postAction && postAction.bind(originalModule);
            if (_.isArray(result) && types.length === 1 && helpers_1.isFuture(_.first(result))) {
                return _.map(result, function (future, index) { return getPromise(future, {
                    postActionMethod: postActionMethod,
                    shouldExecutePostAction: (index + 1) === result.length
                }); });
            }
            else {
                return getPromise(result, {
                    postActionMethod: postActionMethod,
                    shouldExecutePostAction: !!postAction
                });
            }
        };
        return descriptor;
    };
}
exports.exportedPromise = exportedPromise;
function getPromise(originalValue, config) {
    return new Promise(function (onFulfilled, onRejected) {
        if (helpers_1.isFuture(originalValue)) {
            fiberBootstrap.run(function () {
                try {
                    var realResult = originalValue.wait();
                    onFulfilled(realResult);
                }
                catch (err) {
                    onRejected(err);
                }
            });
        }
        else {
            onFulfilled(originalValue);
        }
    }).lastly(function () {
        if (config && config.postActionMethod && config.shouldExecutePostAction) {
            config.postActionMethod();
        }
    });
}
function exported(moduleName) {
    return function (target, propertyKey, descriptor) {
        $injector.publicApi.__modules__[moduleName] = $injector.publicApi.__modules__[moduleName] || {};
        $injector.publicApi.__modules__[moduleName][propertyKey] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var originalModule = $injector.resolve(moduleName), originalMethod = originalModule[propertyKey], result = originalMethod.apply(originalModule, args);
            assert.strictEqual(helpers_1.isFuture(result), false, "Cannot use exported decorator with function returning IFuture<T>.");
            return result;
        };
        return descriptor;
    };
}
exports.exported = exported;
